---
layout: post
title:  "Redis Distributed Lock"
date:   2016-03-29 17:35:21 +0800
categories: redis
---
* content
{:toc}


## 1.我们先了解一下什么是分布式以及它的应用场景

当多个不同进程互斥的方式访问某个共享资源时需要使用到分布式锁来保证各进程安全的访问数据。

## 2.如何借助Redis实现一个分布式锁

### 2.1. 三个原则

安全性：互斥，在任何时候只有一个客户端可以获取到锁

存活性 A:无死锁，无论客户端是否crash掉，总可以获取到一个锁

存活性 B:容错，只要Redis的大部分节点是可用的，客户端就可以获取或者释放锁

### 2.2. 几种实现方式

#### 2.2.1.我们先考虑一种简单的实现方式
依赖redis中过期时间的机制，当获取锁时在实例中创建一个key，释放时候进行删除操作
大多数情况下可以正常运行，但这是一个单点，当实例挂掉怎么办呢？是的挂一个slave上去！可这并不是一个好方案，因为redis的备份是异步进行，这无法满足我们的安全性，那么为什么呢？
这个模型中有个明显的竞态条件

1）Client A在master中获取到了锁

2）master在将key同步到slave之前挂掉了

3）slave升级为了master

4）Client B通过原来的slave的节点获取同样的资源A，违反了安全性。

那我们如何去改进这一做法呢？

#### 2.2.2. 单节点下的一种正确实现方法

获取锁资源

```
    SET resource_name my_random_value NX PX 30000
```

解释一下这个命令,写入一个key为resource_name,value为随机值
，NX表示只有在key存在的情况下才会写入数据，PX表示过期时间的单位为毫秒，设置的过期时间
为30000毫秒。value必须为唯一值，只有这样客户端才可以安全的方式释放一个锁。例如：
只有在key存在，并且value是我之前写入的那个值时才会删除这个key。Lua脚本如下：

```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

如何阻止一个客户端删除一个不是它创建的锁是非常重要的。例如一个获取到了一个锁资源，
但是在被某个操作阻塞住了，直到超了锁的有效时间也就是Redis中的过期时间。然后呢尝试去
释放这个锁，但这个资源已经被其他客户端占用了。简单的使用DEL操作会导致删除其他客户端
写入的key，这是非常不安全的。像上面脚本描述的那样，为每个key设计一个"签名"，这样
这个锁只会被写入的那个客户端所删除。

到这里，我们有了一个安全的获取和释放锁资源的方法。这个系统是假定在一个非分布式，
单点，总是可用的一个系统，那么我们将这些概念扩展到一个分布式系统上来。

#### 2.2.3. Redlock算法
在分布式版本的算法中，我们假设有N个redis-master节点。所有的节点是独立的，我们已经描述
了如何在单机redis下释放和获取锁资源。在我们的例子中，另N=5，这是个有意义的值，
能够保证在大多数独立的情况下使他们出现故障。

为了获取锁，客户端会执行一下步骤

1）获取当前的毫秒级时间

2）客户端尝试顺序的在所有N个redis节点上获取锁，使用相同的key和随机value。
在步骤二的过程中客户端户会设置一个比所有自动释放小的超时时间以便能够获取到锁。
例如：自动释放时间设置为10s，超时时间设置为5-50ms,如果一个实例不可用，我们可以尽快去尝试其他实例而避免超时。

3）客户端为了获得锁会计算从第一步开始花费的时间，当且仅当客户端在大多数节点获得到了锁（最少三个节点），并且总共的花费时间小于锁的存活时间，锁才会被这个客户端获取到。

4）一但客户端获取到了锁，它的存活时间为初始化时间减去步骤3花费的时间

5）如果客户端因为某种原因获取锁的过程中失败了，例如没有在存活时间内在N/2+1个节点以上获取到锁资源，它会尝试在所有的节点上释放锁资源。


#### 2.2.4 失败后的重试操作
如果一个客户端没成功的获取到锁，它会在随机的一段时间后重新尝试获取锁资源。当然客户端尝试的频率越快，空窗期越小，但这样会有可能多个客户端同时尝试获取锁资源，同时获取不到的情况，这时就产生了"脑裂"的现象。所以最理想的情况是客户端用复用技术同时像N个节点发送SET命令。

值得注意的一点，当客户端在大多数节点获取锁时失败了，需要及时的释放掉已获取锁的节点上的key，如果不能及时释放就只能等到过期时间到了其他客户端才可以在这个节点上获取锁了。

#### 2.2.5 释放锁
释放操作比较简单，只需要在所有的节点上执行一遍释放操作，而不管客户端是否在这个节点上获取到了一个锁。


## 3.回顾
我们简单回顾下上面介绍的内容

3.1 介绍了什么是分布式锁以及应用场景

3.2 介绍了分不是锁的一种简单实现，但遇到了安全性的问题

3.3 使用"签名"的机制来保证安全性，说明了使用单节点redis来解决分布式锁的问题。

3.4 根据Redlock算法使用redis集群解决分布式锁的问题


## 4.参考资料

http://redis.io/topics/distlock

http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html

